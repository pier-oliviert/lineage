// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Socket = (function() {

    function Socket(ip, port) {
      this.send = __bind(this.send, this);

      this.process = __bind(this.process, this);

      this.received = __bind(this.received, this);

      this.bufferize = __bind(this.bufferize, this);

      this.connected = __bind(this.connected, this);

      var _this = this;
      this.socket = chrome.socket;
      this.socketId = -1;
      this.encryptor = new Encryptor();
      this.decryptor = new Decryptor();
      this.buffer = new Buffer;
      this.socket.create("tcp", {}, function(info) {
        _this.socketId = info.socketId;
        console.log("Connecting to " + ip + ":" + port);
        return _this.socket.connect(_this.socketId, ip, port, _this.connected);
      });
    }

    Socket.prototype.connected = function(e) {
      if (e === 0) {
        console.log("Connected to server");
        return setInterval(this.bufferize, 500);
      } else {
        throw "Couldn't connect to server. Please restart the application";
      }
    };

    Socket.prototype.bufferize = function() {
      return this.socket.read(this.socketId, null, this.received);
    };

    Socket.prototype.received = function(packet) {
      var receivingPacket,
        _this = this;
      if (!(packet.resultCode > 0)) {
        return;
      }
      receivingPacket = function(packet) {
        var _results;
        if (!(packet.resultCode > 0)) {
          return;
        }
        if (_this.buffer.empty()) {
          _this.buffer.initialize(new Uint8Array(packet.data));
        } else {
          _this.buffer.append(new Uint8Array(packet.data));
        }
        _results = [];
        while (_this.buffer.full()) {
          _results.push(_this.process(_this.buffer.data()));
        }
        return _results;
      };
      return this.received = receivingPacket;
    };

    Socket.prototype.process = function(encryptedData) {
      var data, opcode;
      data = this.decryptor.process(new Uint8Array(encryptedData));
      opcode = data[0];
      if (chrome.app.Routes[opcode] != null) {
        return Lineage.current().received(new chrome.app.Routes[opcode](data.subarray(1)));
      }
    };

    /*
      #   Discussion: How the server handles the length of a packet goes as follow:
      #   If a packet is smaller than 256bytes, the high byte is used. If however, the message is
      #   bigger than 256bytes, you use the low byte as a multiplicator. 
      #   The length of a packet is assumed to be: lowByte * 256 + highByte
      #
      #   Discussion: We assume the packet size is at least 4 bytes long. Otherwise, it would disconnect us
      #   from the server. If the packet is less than 4 bytes, we raise an exception and return without sending it
    */


    Socket.prototype.send = function(data) {
      var packet, size;
      if (data.length < 4) {
        throw "Packet size error: A packet with a size less than 4 bytes was about to be sent";
        return;
      }
      data = this.encryptor.process(data);
      size = data.length + 2;
      packet = new Int8Array(size);
      packet[0] = size % 256;
      packet[1] = (size / 256) & 0xFF;
      packet.join(data, 2);
      return this.socket.write(this.socketId, packet.buffer, function(e) {});
    };

    return Socket;

  })();

}).call(this);
