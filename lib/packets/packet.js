// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  this.Packet = (function() {

    Packet.prototype.packaged = void 0;

    function Packet(op) {
      this["package"] = __bind(this["package"], this);
      this.op = op;
    }

    /*
      # returns the expected length of the buffer.
      # The length is a multiple of 8 since we are
      # using 8 bytes encodings
      # Note:
      #   - You have to overwrite this method
      #   - By default you want to send the opcode(1)
      #
    */


    Packet.prototype.length = function() {
      return 1;
    };

    /*
      # Int8Array that is available for work.
      # We are using Int8Array since it's the way the server interprets packet
      # https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays?redirectlocale=en-US&redirectslug=JavaScript_typed_arrays
      # Note:
      #   - The opcode is already filled.
      #   - The high & low byte are already filled based on length()
      #   - You have to overwrite this method
      #   - When your packaging is done. You have to call @packaged(buffer) or super to notify the callback
    */


    Packet.prototype["package"] = function(buffer) {
      return this.packaged(buffer);
    };

    /*
      # Don't subclass this method. 
      # Subclass @package instead!
      #
      #   Discussion: Since the encryption is being done using the 4 first byte, a packet has to be
      #   at least 4 bytes wide.
    */


    Packet.prototype.bufferize = function(callback) {
      var view;
      if (callback == null) {
        throw "Error: No callbacks given. This packet won't be sent";
      }
      this.packaged = callback;
      view = new Int8Array(Math.max(this.length(), 4));
      view[0] = this.op & 0xFF;
      return this["package"](view);
    };

    return Packet;

  })();

}).call(this);
