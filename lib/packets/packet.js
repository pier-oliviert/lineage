// Generated by CoffeeScript 1.4.0
(function() {

  this.Packet = (function() {

    function Packet(op, types) {
      if (types == null) {
        types = [];
      }
      this.op = op;
      this.states(types);
      if (this.states().length === 0) {
        this.ready();
      }
    }

    Packet.prototype.ready = function() {
      var callback, _i, _len, _ref, _results;
      this["package"](this.buffer());
      _ref = this.onReady();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        callback = _ref[_i];
        _results.push(callback(this.buffer()));
      }
      return _results;
    };

    Packet.prototype.onReady = function() {
      this.onReady = function() {
        if (arguments.length === 0) {
          return this.onReady.value;
        }
        if (this.states().length === 0) {
          return arguments[0](this.buffer());
        } else {
          return this.onReady.value.push(arguments[0]);
        }
      };
      this.onReady.value = [];
      if (arguments.length !== 0) {
        this.onReady.value.push(arguments[0]);
      }
      return this.onReady();
    };

    /*
      # return unprocessed states.
      # The types given in the constructor is passed
      # to this function will save the states.
      # when packed() is called, it will removed the state
      # associated with the packed data.
    */


    Packet.prototype.states = function() {
      this.states = function() {
        if (arguments.length === 0) {
          return this.states.value;
        }
        return this.states.value = arguments[0];
      };
      this.states.value = arguments[0];
      return this.states();
    };

    /*
      # Callback triggered when a data that needed processing is done
      # This can be called by a packet directly if no processing needs to 
      # be done. An example would be to set an integer.
      # This will replace the initial function with a 
      # getter that can be used by the packet to assemble
      # the buffer before sending it down the pipes.
      #
      # Updates @states(), if no state need to be processed. Calls @ready()
    */


    Packet.prototype.packed = function(type, data) {
      this[type] = function() {
        return data;
      };
      this.states().splice(this.states().indexOf(type), 1);
      if (this.states().length === 0) {
        return this.ready();
      }
    };

    /*
      # Int8Array that is available for work.
      # We are using Int8Array since it's the way the server interprets packet
      # https://developer.mozilla.org/en-US/docs/JavaScript/Typed_arrays?redirectlocale=en-US&redirectslug=JavaScript_typed_arrays
      # Note:
      #   - The opcode is already filled.
      #   - The high & low byte are already filled based on length()
      #   - You should overwrite this method, unless you don't need to add anything
    */


    Packet.prototype["package"] = function(buffer) {};

    /* You should use this method when you want to 
    # send a string in the packet. This will call @packed()
    # when done. String always ends with 0x00 this is why the extra byte
    */


    Packet.prototype.process = function(string, type) {
      var b, f,
        _this = this;
      b = new Blob([string]);
      f = new FileReader();
      f.onload = function(e) {
        var buffer, data;
        buffer = new Uint8Array(e.target.result);
        data = new Uint8Array(buffer.length + 1);
        data.set(buffer);
        return _this.packed(type, data);
      };
      f.readAsArrayBuffer(b);
      return this;
    };

    /*
      # returns the expected length of the buffer.
      # The length is a multiple of 8 since we are
      # using 8 bytes encodings
      # Note:
      #   - You have to overwrite this method
      #   - By default you want to send the opcode(1)
      #
    */


    Packet.prototype.length = function() {
      return 1;
    };

    /*
      # Don't subclass this method. 
      # Subclass @package instead!
      #
      #   Discussion: Since the encryption is being done using the 4 first byte, a packet has to be
      #   at least 4 bytes wide.
    */


    Packet.prototype.buffer = function() {
      var buffer;
      this.buffer = function() {
        return this.buffer.value;
      };
      buffer = new Int8Array(Math.max(this.length(), 4));
      buffer[0] = this.op & 0xFF;
      this.buffer.value = buffer;
      return this.buffer();
    };

    return Packet;

  })();

}).call(this);
